# 以下是各个类在设计时的想法

## 定时器

定时器的功能是设置一个固定的时间，当时间到了以后会自动的触发一个函数。所以设计了`setTimeoutTimer`。但是，也有可能会存在固定时间触发一次的任务，所以，设计了`setPeriodicTimer`这个函数，用于创建一个固定时间间隔的定时器。

由于无法估计定时器中会存放什么任务，所以有可能是耗时长的任务。而在定时器这个线程执行长耗时任务时，会影响定时器的稳定性。所以考虑到了使用线程池来处理。而定时器与线程池是完全独立的两个模块，所以这两者之间不能直接调用，不然不符合高内聚，低耦合的设计理念。所以这里设计了一个执行器。可以将线程池的提交函数传入，从而来实现线程池与定时器的解耦。如果没有传入线程池的提交函数，则会有一个默认的函数。

有了创建一个定时器的功能，自然也就有了移除定时器的功能。这里就设计了`removeTimer`函数，可以通过定时器id来取消之前设置好的定时器。

## 线程池

线程池是用于管理线程的，程序中所有的耗时任务都可以由其完成。

该线程池可以动态的扩充与减少线程，考虑到任务分为CPU密集型与IO密集型，当CPU密集型的任务数量等于硬件的核心数时，则不再扩充新的线程。提交一个任务的函数为`commit`，两个参数，一个是要执行的函数，一个是指明该函数是不是cpu密集型任务。

为了方便察看线程池中的各个数据，同时保持线程池的代码的简洁，设计了一个`ThreadPoolMonitor`类，该类可直接察看线程池的成员变量。

## Buffer

这个是用于反应堆模型中的数据缓冲区。一开始就打算用一个array来存放数据，然后由于每次读出数据后都会将元素复制到队头，所以打算用一个循环数组，从而减少复制的开销。

这样就可以使用deque，但是考虑到deque的空间是动态申请的，为了更大程序的减小开销，这里就自定义了这个类，并且使用了memcpy来优化大量数据的复制情况。

## TcpClient & TcpServer

这两个是一对，而且只有这两个才能连接，使用其他的软件来连接TcpServer会报错。原因是：这个tcp客户端与服务端处理了tcp粘包的问题：通过在每段消息前加上数据长度来解决。所以，如果直接使用其他的tcp客户端（比如`nc`）会出错。

服务端使用`reactor-ms`模式实现，并且二者都可以连接线程池，通过线程池来完成多线程的处理。

## 序列化与反序列化

该类是在b站上一个类改过来的。原代码：https://www.bilibili.com/video/BV1ad4y1x7VY

我使用了模板重载了部分的代码，同时还使用了c++20中的概念（concept）来限制了支持的类型。同时还添加了`unordered_map`与`unordered_set`的支持。
